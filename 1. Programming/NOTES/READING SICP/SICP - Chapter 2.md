### 1.2.0 Procedures and the Processes They Generate
**Abelson & Sussman** • 1996 • Book
##### Hashtags
#SICP
[[TYCS/1. Programming/README|README]]

---
## Notes
- Procedures as Patterns
	- how each stage of the process is built upon the prior
	- Global and Locale

---
### 1.2.1 Linear Recursion and Iteration

**Abelson & Sussman** • 1996 • Book
##### Hashtags
#SICP
[[TYCS/1. Programming/README|README]]

---
## Notes
- Factorials
	- #### n!=n⋅(n−1)⋅(n−2)⋯3⋅2⋅1.
		- **n!** is equal to *n* times *(n - 1)* for any positive inter ***n**
			- n!=n⋅\[(n−1)⋅(n−2)⋯3⋅2⋅1]=n⋅(n−1)!
		- In recursion we will compute down to (n-1)! and multiply the result by ***n**
		- 1! =1 
```scheme
(define (factorial n)
	(if (n = 1) 
		1
		(* n (factorial (- n 1))))
```

![[Pasted image 20250923150639.png]]
- This is ***DEFERRED OPERATION** 
	- there is an expansion as the process builds up
	- Then a contraction as the operations are performed
	- ### Which makes a ***Recursive Process**
		- the processor must track processes to be carried out later
		- *n* is proportional to *n*
		- GROWS LINEARLY and hence is...
			- ### LINEAR RECURSIVE PROCESS
			- the larger the chain of deferred ops the more info must be maintained
- # Factorial With a COUNTER
- we could have n move up in count
	- Multiply **1** by **2** then the result by **3**, then **4**, so forth until we reach ***n**
		- We must maintain a running product together with a counter that counts up from 1 to ***n**
		- My Lexical Scoped Factorial w/ Counter Below
```Scheme
(define (factorial n)                 ; our defined function that takes a number
	(define (fact-int product counter); method
		(if (> counter n)
			product
			(fact-int (* counter product)
					  ( + counter 1))))
	(fact-int 1 1))
```
![[Pasted image 20250923152021.png]]
- ##### Does NOT GROW and SHRINK
	- We keep track of only the values of **3** *Variables*
	- this is a....
	- ### ITERATIVE PROCESS
		- ...which is one whose state can be summarized by a fixed number of state variables
			- along with fixed rules with how they are updated
			- and conditions at which the test should terminate
	- **n!** is....
	- ### LINEAR ITERATIVE PROCESS
- ### Tail-Recursive
	- creating a looping like call by using recursion and  not using <code>do, repeat, until, for, while</code>
- ##### Recursive Process is not a Recursive Procedure
	- Process is how it evolves, say linearly 
	- Procedure is how it is syntactically written 
## Exercises
##### **Exercise 1.9:** 
Each of the following two procedures defines a method for adding two positive integers in terms of the procedures `inc`, which increments its argument by 1, and `dec`, which decrements its argument by 1.
##### My Note: *this exercise redefines + as if it wasn't already a primitive. Very confusing yes, if you didnt know*

(define (+ a b)
  (if (= a 0) 
      b 
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0) 
      b 
      (+ (dec a) (inc b))))

Using the substitution model, illustrate the process generated by each procedure in evaluating `(+ 4 5)`. Are these processes iterative or recursive?
```scheme
(+ 4 5)
(if ( = 4 0) 5 (inc (+ (dec 4) 5)))
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (if (= 3 0) 5 (inc (+ (dec 3) 5))))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (if (= 2 0) 5 (inc (+ (dec 2) 5))))
(inc (inc (inc (+ (dec 2) 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (if (= 1 0) 5 (inc (+ (dec 1) 5))))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc (if (= 0 0) 5) (+ (dec 0) 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc (+ 5 1))))
(inc (inc (inc 6)))
(inc (inc (+ 6 1)))
(inc (inc 7))
(inc (+ 7 1))
(inc 8)
(+ 8 1)
9
; The above calls are linearly recursive. It builds up a stack of procedures till it breaks out and succesivly runs down them
;==================================
(+ 4 5)
(if ( = 4 0) 5 (+ (dec 4) (inc 5)))
(+ (dec 4) (inc 5))
(+ 3 6)
(if (= 3 0) 6 (+ (dec 3) (inc 6)))
(+ (dec 3) (inc 6))
(+ 2 7)
(if (= 2 0) 7 (+ (dec 2) (inc 7)))
(+ (dec 2) (inc 7))
(+ 1 8)
(if (= 1 0) 8(+ (dec 1) (inc 8)))
(+ (dec 1) (inc 8))
(+ 0 9)
(if (= 0 0) 9 (+ (dec 0) (inc 9)))
9
; these are linearly iterative. It tracks two variables states' over the life cycle of the function till it breaks out.

```

#### **Exercise 1.10:**
The following procedure computes a mathematical function called Ackermann’s function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

What are the values of the following expressions?

(A 1 10)
(A 2 4)
(A 3 3)
```Scheme
(cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
;(1 = x, 10 = y)
(A 1 10)		
(cond ((= 10 0) 0) 
	  ((= 1 0)(* 2 10) 
	  ((= 10 1) 2)
	  (else (A (- 1 1) (A 1 (- 10 1)))))
; False cond's, eval else
(A (- 1 1) (A 1 (- 10 1)))
(A 0 (A 1 9))
(A 0 (cond ((= 9 0) 0)      
           ((= 1 0) (* 2 9))
           ((= 9 1) 2)
           (else (A (- 1 1) (A 1 (- 9 1))))))
           ;EVAL ELSE
(A 0(A (- 1 1) (A 1 (- 9 1))))
(A 0(A 0 (A 1 8)))
(A 0(A 0 (cond((= 8 0) 0)
			 ((= 1 0) (* 2 8))
			 ((= 8 1) 2)
			 (else (A (- 1 1) (A x (- 8 1)))))))
(A 0(A 0 (A (- 1 1) (A 1 (- 8 1)))
(A 0(A 0 (A 0 (A 1 7))))
(A 0(A 0 (A 0 (cond ((= 7 0) 0)
			       ((= 1 0) (* 2 8))
			       ((= 7 1) 2)
			       (else (A (- 1 1) (A 1 (- 7 1))))))))
(A 0(A 0 (A 0 (A (- 1 1) (A 1 (- 7 1)))))
(A 0(A 0 (A 0 (A 0 (A 1 6))))))
(A 0(A 0 (A 0 (A 0 (cond ((= 6 0) 2)
                        ((= 1 0)(* 2 6))
                        ((= 6 1) 2)
                        (else (A (- 1 1) (A 1 (- 6 1)
(A 0(A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1)))))))
(A 0(A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0(A 0 (A 0 (A 0 (A 0 (cond ((= 5 0) 0)
                             ((= 1 0)((* 2 5))
                             ((= 5 1) 2)
                             (else (A (- 1 1) (A 1 (- 5 1)))))))))))
(A 0(A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1)))))))))
(A 0(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2))))))))
(A 0(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))));satisfies cond((= y 1) 2)
(A 0(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))  ; satisfies cond((= x 0) (* 2 y))
(A 0(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))
(A 0(A 0 (A 0 (A 0 (A 0 (A 0  (A 0 8)))))
(A 0(A 0 (A 0 (A 0 (A 0  (A 0 16))))
(A 0(A 0 (A 0 (A 0 32))
(A 0(A 0 (A 0 (A 0 64)))
(A 0(A 0 (A 0 128))
(A 0 (A 0 256)
(A 0 512)
1024

(A 2 4)
(cond ((= 4 0) 0)
      ((= 2 0) (@ 2 y))
      ((= 4 1) 2)
      (else (A (- x 1) (A x (- y 1)))))
(A (- 2 1) (A 2 (- 4 1)))
(A 1 (A 2 3))
(A 1 (A (- 2 1)(A 1 (- 3 1)))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A (- 2 1) (A 1 (- 2 1))))))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 4))
(A 1 8)
(A (- 1 1)(A 1 (- 8 1)))
(A 0 (A 1 7))
(A 0 (A 0 (A 1 6))
(A 0 (A 0 (A 0 (A 1 5))
(A 0 (A 0 (A 0 (A 0 (A 1 4))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)
(A 0 (A 0 (A 0 (A 0 (A 0 8)
                 16
             32
        64   
    128
256







```
Consider the following procedures, where `A` is the procedure defined above:

(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

Give concise mathematical definitions for the functions computed by the procedures `f`, `g`, and `h` for positive integer values of n. For example, `(k n)` computes 5n2.

===This shits tough, its dooing some looping and nesting and tree stuff.... shorthands killing me===
## Key Ideas
EXAMPLE COUNTING CHANGE
- how many ways can we make a dollar
	- given .50, .25, .10, .05, .01
- *The number of ways to change amount a using n kinds of coins*
	- the number of ways to chane amount a using all but the first kind of coin plus
	- the number of wasy to change amount a- d using all the n kinds of coins where d is the denomination of the fist kind of coin.
## Quotes

## Links

[[]]

---


